---
layout:     post
title:      算法导论第22章
subtitle:   读书笔记
date:       2020-03-23
author:     DT
header-img: img/post-bg-debug.png
catalog: true
tags:
    - notes
    - 算法导论


---

> 算法导论——第22章——基本的图算法

# 22 基本的图算法

## 22.1 图的表示

* **图的两种最常用表示方式**：邻接链表，邻接矩阵。

* **稀疏图**    图的边数$\left|E\right|$远远小于$\left|V\right|^2$。（想想一个带环的且两两相连的图的边数为$|V|^2$）

* **稠密图**    图的边数$\left|E\right|$接近$\left|V\right|^2$。

* **邻接链表** 定义——> 一个包含了$\left|V\right|$条链表的数组$Adj$，该数组中的每个结点保存了一条链表的位置，且对于图的每个结点$u \in V$，$G.Adj\left[u\right]$中包含了图$G$中所有与$u$相连的结点；空间复杂度：对于无向图为$\left|V\right|+2\left|E\right|$，对于有向图为$|V|+|E|$，故而总括为$\Theta(\left|V\right|+\left|E\right|)$（这个正是我们所希冀的复杂度）；带权图：在链表中的每个结点中添加对应权重即可；优点：空间复杂度低；缺点：无法快速判断一条边$(u,v)$是否在图中，只能遍历链表。

* **邻接矩阵**    定义——> 一个$\left|V\right|\times\left|V\right|$的二维矩阵；空间复杂度——>无论$\left|E\right|$为多少，皆为$\Theta(\left|V\right|^2)$（表示无向图时，为一个对称矩阵，可压缩一半）；带权图——>对应位置设置权重即可；优点——>可快速判断边$(u,v)$是否在图中；缺点——>空间复杂度高。

* **图的顶点属性的表示 ——> 在采用邻接链表表示法时，一般采用一个额外的数组来存储结点属性，譬如一个与$G.Adj$相对应的数组$d\left[1,...,\left|V\right|\right]$。

其余：稀疏图一般用邻接链表表示，稠密图以及小图一般用邻接矩阵表示。

## 22.2 广度优先搜索

* 给定图$G=(V,E)$和源结点$s$，对于任意从$s$出发可以到达的结点$v$，使用BFS就可以找到从$s$出发到达$v$的最短距离或者路径（有向图无向图都适用）。（所以，给定两个结点，使用BFS就可以找到他们之间的最短路径或者距离）

* BFS可以发现从源结点$s$出发所能到达的所有结点，并且所发现的从$s$到可达结点$v$之间的距离/路径也是最短的。

* BFS从$s$出发，可以生成一棵**广度优先搜索树**：该树以$s$为根，包含了所有可以从$s$到达的结点；树中$s$到$v$的简单路径，就对应了图中$s$到$v$的最短路径。

* BFS原理：算法在发现了**距离源节点$s$距离为k的所有结点**之后，才会去发现距离源节点$s$为k+1的其他结点。

* 在BFS的执行过程中，会构造出来一棵广度优先搜索树。（既然是树，那么必须会形成树的形状。）

* 一个结点被发现：第一次遇到一个结点时就称该结点**被发现**；从$u$的邻接链表发现$v$，称$u$是$v$的前驱或者父结点；由于每个结点最多被发现一次，所以其最多只会有一个父结点。

* ```python
  # 从s出发进行搜索的BFS
  BFS(G, s):
    # 设置G中除s之外的所有结点 1）为白色：表示尚未被发现；2）到s的距离为INF（无穷大）；3）前驱为NULL
    for u in G.V-{s}:
      u.color = WHITE #还没有被访问
      u.d = INF # 距离源结点s为无穷大
      u.pai = NULL # 前驱结点尚未得到
    # 因为s是源结点，所以可发现，距离为0，前驱为NULL；所以设置s
    s.color = GRAY # 表示该结点已经被发现，但是其邻接链表尚未被检查（书上说：尚未被完全检查；我认为是压根还没被检查）
    s.d = 0
    s.pai = NULL
    # 循环不变式：队列中存放的都是灰色的结点
    Q = NULL
    ENQUEUE(Q, s) # 入队
    while not Q.empty():
      u = DEQUEUE(Q) # 取出队首，因为我要操作；同时这样不会产生副本
      # 遍历u的链接链表
      for v in G.Adj[u]:
        if v.color == WHITE:
        	v.color = GRAY
          v.d = u.d+1
          v.pai = u
          ENQUEUE(Q, v) # v的邻接链表还没有被访问，所以要入队
        else:
          pass # v如果已经是 gray or black，说明v已经可以通过其他更短的路径从s出发到达了，没有必要走s....->u->v的路径
      # u的邻接链表已经被完全访问完，改成黑色
      u.color = BLACK
  ```

* BFS时间复杂度    $O(\left|V\right|+\left|E\right|)$.每个结点只在初始化的时候被涂为白色（其余没有任何机会），且只有一次入队机会，且每个结点的邻接链表最多被扫描一次，所以就是$O(\left|V\right|+\left|E\right|)$.


